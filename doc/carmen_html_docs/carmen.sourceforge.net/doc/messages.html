<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from carmen.sourceforge.net/doc/messages.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 13 Jan 2011 17:36:06 GMT -->
<head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CARMEN: </title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h2>Carmen Messages</h2>
<h2><a class="anchor" name="messages_introduction">
Introduction</a></h2>
In all messages, the distance units are in metres. Angle measurements in radians, in the range <img class="formulaInl" alt="$-\pi$" src="form_2.png"> to <img class="formulaInl" alt="$\pi$" src="form_3.png"> . Velocity units are m/sec. The timestamp is given as the number of seconds since the unix epoch, and is a double, where the fractional part is computed from the <code>tv_usec</code> field of the <code>timeval</code> struct returned by <code>gettimeofday</code>. More information on units and co-ordinate frames can be found in the Carmen Programming Style Guide.<h2><a class="anchor" name="messages_gettingdata">
Getting Data from Carmen</a></h2>
Sensor data currently comes from one of two sources: the base module (such as scout, pioneer, etc.) provides raw odometry data and may provide sonar data, bumper data and infra-red (IR) data. The laser module may provide laser data.<h3><a class="anchor" name="messages_sub_sub">
Subscribing</a></h3>
All of the following messages can be subscribed to by using helper functions in the appropriate <code>xxx_interface</code> library, e.g., <code>base_interface</code>. The helper functions are all of the form:<p>
<div class="fragment"><pre class="fragment">void carmen_robot_subscribe_xxxx_message(carmen_robot_xxx_message *msg,
                                         carmen_handler_t handler, 
                                         carmen_subscribe_t subscribe_how);
</pre></div><p>
where <code>carmen_handler_t</code> and <code>carmen_subscribe_t</code> are defined as<p>
<div class="fragment"><pre class="fragment">typedef enum {CARMEN_UNSUBSCRIBE, CARMEN_SUBSCRIBE_LATEST, 
              CARMEN_SUBSCRIBE_ALL} carmen_subscribe_t;
typedef void (*carmen_handler_t)(void *);
</pre></div><p>
If the <code>msg</code> field of the subscribe function is <code>NULL</code>, then a static message is automatically allocated and returned as the argument to <code>handler</code>, otherwise the message pointer passed to the subscribe function is always used. In all cases, the same memory is re-used for all handled messages of the same message name, and passed as an argument to the handler function.<p>
If the <code>handler</code> field of the subscribe function is <code>NULL</code>, no handler is called, but the memory pointed to by <code>msg</code> is updated regularly. If both <code>handler</code> and <code>msg</code> are both <code>NULL</code>, your program will spend a fair chunk of time doing nothing useful for you.<p>
The <code>subscribe_how</code> field allows the user to either unsubscribe, or to start a new subscription. Subscribing only to the latest message allows the module to fall behind in processing messages without serious consequences. It should be pointed out that subscribing to all messages (<code>CARMEN_SUBSCRIBE_ALL</code>) does not guarantee all messages. Currently, the upper limit for the queue size is 1000 messages. If an IPC process actually subscribes to {all} messages and falls seriously behind (or wedges), central can run out of memory, or even worse, the TCP stack can overflow. Consequently, the Carmen subscription functions limit the maximum message queue size to 1000. A resourceful programmer can increase this queue (or even remove the queue size), but it is not clear this would ever be necessary.<h3><a class="anchor" name="messages_requesting">
Requesting Data Explicitly</a></h3>
Some of these messages can also be obtained using explicit queries. To date, the only robot data that can be obtained using queries are from localize and navigator. Specifically, <code><a class="el" href="structcarmen__localize__globalpos__message.html">carmen_localize_globalpos_message</a></code>, <code><a class="el" href="structcarmen__localize__particle__message.html">carmen_localize_particle_message</a></code>, <code><a class="el" href="structcarmen__navigator__status__message.html">carmen_navigator_status_message</a></code> and <code><a class="el" href="structcarmen__navigator__plan__message.html">carmen_navigator_plan_message</a></code> can all be obtained using specific query interface functions, which return the appropriate messages directly.<p>
These functions create new memory every time they return successfully; consequently, they should be used with care.<h4><a class="anchor" name="messages_base">
Sensor Data from the Base</a></h4>
The <code>timestamp</code> field in all messages is defined to be the time when the data was first created or acquired (e.g, by <code>scout</code> or <code>simulator</code>).<h4><a class="anchor" name="messages_odom">
Odometry</a></h4>
<div class="fragment"><pre class="fragment">void carmen_base_subscribe_odometry_message(carmen_base_odometry_message *odometry,
                                            carmen_handler_t handler,
                                            carmen_subscribe_t subscribe_how);
</pre></div><p>
The <code>x</code>, y, theta fields are the raw odometry, from the time the robot was turned on. The tv and rv fields are the translational and rotational velocities of the robot. For robots that have differential drive (as opposed to synchrodrive), these velocities are computed from the left and right wheel velocities that base actual uses.<h4><a class="anchor" name="messages_sonar">
Sonar</a></h4>
Sonar sensing is not properly supported by Carmen right now, and so subscribing to <code><a class="el" href="structcarmen__base__sonar__message.html">carmen_base_sonar_message</a></code> messages may sometimes not work properly. But, if you care, it looks like:<p>
<div class="fragment"><pre class="fragment">void carmen_base_subscribe_sonar_message(carmen_base_sonar_message *sonar,
                                         carmen_handler_t handler,
                                         carmen_subscribe_t subscribe_how);
</pre></div><p>
The sonar message reports a recent set of sonar range data from the base. There should be as many range points and offset points as described by <code>num_sonars</code>. The <code>sonar_offsets</code> describes the physical location and orientation of each transducer from the centre of the robot.<p>
There is currently no way to query the firing rate or order of the sonar transducers, and the sonar message is not yet supported. (Or even defined by any module.)<p>
\subsubsection lmessages_laser Laser data<p>
Laser data is defined as a set of ranges, of number given by the <code>num_readings</code> field, contained in <code>range</code>. The number of ranges is almost always 180, since we only support SICK lasers in <img class="formulaInl" alt="$1^\circ$" src="form_4.png"> increments at the moment. Each range measurement is the distance to the nearest obstacle along some heading. The first range is along the <img class="formulaInl" alt="$-\pi/2$" src="form_5.png"> direction (of course, in the robot's local frame of reference, where <img class="formulaInl" alt="$0^\circ$" src="form_6.png"> is directly ahead) and the last range is along the <img class="formulaInl" alt="$+\pi/2-\frac{1}{180}$" src="form_7.png"> heading. In degrees, that is from <img class="formulaInl" alt="$-90^\circ$" src="form_8.png"> to <img class="formulaInl" alt="$+89^\circ$" src="form_9.png"> . The increment is currently <img class="formulaInl" alt="$1^\circ$" src="form_4.png"> . The order is right-handed (counter-clockwise). Remember that this is all with reference to a laser that is mounted facing the front of the robot, with the laser right way up (the serial and power connectors are on top). For rear laser messages, the measurements go from <img class="formulaInl" alt="$+\pi/2$" src="form_10.png"> through <img class="formulaInl" alt="$\pi$" src="form_3.png"> to <img class="formulaInl" alt="$-\pi/2-\frac{1}{180}$" src="form_11.png"> . If you mount the laser upside down, the measurements go from <img class="formulaInl" alt="$+\pi/2$" src="form_10.png"> through <img class="formulaInl" alt="$0$" src="form_12.png"> to <img class="formulaInl" alt="$-\pi/2-\frac{1}{180}$" src="form_11.png"> . For forward pointing lasers, you can pretty much assume the laser is mounted the right way up.<p>
The <code>timestamp</code> field in all messages is defined to be the time when the data was first created or acquired (e.g, by <code>laser</code> or <code>simulator</code>), not the timestamp of some intermediate process (such as the correction applied by <code>robot</code> when applying odometry interpolation and correction). Similarly, the <code>hostfield</code> is defined to be the hostname associated with the origin of the data, not the hostname of some intermediary converting the data from raw form to interpolated form.<p>
<div class="fragment"><pre class="fragment">void carmen_laser_subscribe_frontlaser_message(carmen_laser_laser_message *laser,
                                               carmen_handler_t handler,
                                               carmen_subscribe_t subscribe_how);
void carmen_laser_subscribe_rearlaser_message(carmen_laser_laser_message *laser,
                                              carmen_handler_t handler,
                                              carmen_subscribe_t subscribe_how);
</pre></div><p>
This message is defined by <code>laser</code> and by <code>simulator</code>, and the same message struct is used by both <code>carmen_laser_frontlaser</code> and <code>carmen_laser_rearlaser</code> messages. As a consequence, there is no way to tell from a message itself whether or not the message is a front laser message or a rear laser message. This hopefully will be fixed in a future release.<h4><a class="anchor" name="messages_robot">
Robot messages</a></h4>
These messages are defined and emitted by <code>robot</code>.<p>
<ul>
</ul>
<code><a class="el" href="structcarmen__robot__laser__message.html">carmen_robot_laser_message</a></code> <p>
<div class="fragment"><pre class="fragment">void carmen_robot_subscribe_frontlaser_message(carmen_robot_laser_message *laser,
                                               carmen_handler_t handler,
                                               carmen_subscribe_t subscribe_how);

void carmen_robot_subscribe_rearlaser_message(carmen_robot_laser_message *laser,               
                                              carmen_handler_t handler,
                                              carmen_subscribe_t subscribe_how);

</pre></div><p>
The <code><a class="el" href="structcarmen__robot__laser__message.html">carmen_robot_laser_message</a></code> has raw odometry attached to it. The <code>robot</code> module attempts to adjust for clock skews and interpolate the true robot position of the data correctly based on time stamps. Consequently, after a <code><a class="el" href="structcarmen__laser__laser__message.html">carmen_laser_laser_message</a></code> is received, the corresponding <code><a class="el" href="structcarmen__robot__laser__message.html">carmen_robot_laser_message</a></code> will not be emitted until a <code><a class="el" href="structcarmen__base__odometry__message.html">carmen_base_odometry_message</a></code> with a later timestamp is received. The odometry fields are <code>x</code>, <code>y</code> and <code>theta</code>. These fields are in fact the interpolated position of {this laser}, based on the laser offset parameters for this laser. The interpolated odometry for the robot itself are the <code>odom_x</code>, <code>odom_y</code> and <code>odom_theta</code> fields. Consequently, front and rear laser messages with the same timestamps should have different values for their <code>x</code>, <code>y</code> and <code>theta</code> fields, but identical values for their <code>odom_x</code>, <code>odom_y</code> and <code>odom_theta</code> fields.<p>
The <code>robot</code> module is also used to perform collision avoidance, stopping the robot if the laser measurements indicate an obstacle inside safety margins. The <code>tooclose</code> array labels each range measurement as to whether or not it lies inside the robot safety margins. There are as many <code>tooclose</code> elements as there are <code>range</code> elements (as given by the <code>num_readings</code> field). If <code>msg.tooclose</code>[i] is 1, then the range <code>msg.range</code>[i] is inside the safety margin.<p>
The same message struct is used by both the <code>carmen_robot_frontlaser</code> and <code>carmen_robot_rearlaser</code> messages. Again, there is no way to tell from a message itself whether or not the message is a front laser message or a rear laser message. This hopefully will be fixed in a future release.<h3><a class="anchor" name="messages_map">
Map-based Navigation Messages</a></h3>
<h4><a class="anchor" name="messages_localize">
Localize Messages</a></h4>
<ul>
</ul>
<code><a class="el" href="structcarmen__localize__globalpos__message.html">carmen_localize_globalpos_message</a></code> <p>
<div class="fragment"><pre class="fragment">void carmen_localize_subscribe_globalpos_message(carmen_localize_globalpos_message *globalpos,
                                                 carmen_handler_t handler,
                                                 carmen_subscribe_t subscribe_how);
</pre></div><p>
This message reports on the current robot pose estimate, given by localize.<p>
The <code>globalpos</code> field is mean robot position (computed from the particle filter), and is given in the global frame of reference. (See the Carmen Style Guide.) The <code>odometrypos</code> is the odometry of the robot at the time the current estimate was computed. It is therefore possible to estimate the true position of the robot for a short duration after the last <code><a class="el" href="structcarmen__localize__globalpos__message.html">carmen_localize_globalpos_message</a></code> by finding the relative displacement (translational and rotational) of the robot between the current odometry, and the odometry of the last <code><a class="el" href="structcarmen__localize__globalpos__message.html">carmen_localize_globalpos_message</a></code>, and then adding this displacement to the <code>globalpos</code> field. There is a helper function in <code>liblocalize_interface</code> called <code>carmen_localize_correct_odometry</code> that does exactly this.<p>
Notice that Carmen localize no longer explicitly provides correction parameters, but instead provides a functional way to correct odometry.<p>
The <code>globalpos_std</code> gives the variances of the position estimates, <img class="formulaInl" alt="$\sigma_x^2, \sigma_y^2, \sigma_\theta^2$" src="form_13.png"> . The <code>globalpos_xy_cov</code> field gives the covariance <img class="formulaInl" alt="$\sigma_{xy}$" src="form_14.png"> .<p>
The <code>converged</code> field indicates whether localize is currently in global or tracking mode. If localize has converged (is in tracking mode) then the position estimate has high confidence. When localize believes it is lost, it switches back to global localization mode and the <code>converged</code> field switches to 1.<p>
Additional messages about the state of localize are:<p>
<ul>
<li><code><a class="el" href="structcarmen__localize__particle__message.html">carmen_localize_particle_message</a></code> -- This message gives the full state of the pose particle filter (and people particle filters, if people tracking is running.)</li>
</ul>
<ul>
<li><code><a class="el" href="structcarmen__localize__sensor__message.html">carmen_localize_sensor_message</a></code> -- This message contains information about how localize has used each laser reading, such as whether a laser readings was integrated (or not), and which person filter the reading was assigned (if any).</li>
</ul>
<ul>
<li><code>carmen_localize_people_message</code> -- This message contains the current state of the person tracker, if it is running. </li>
</ul>
<h4><a class="anchor" name="messages_autonav">
Autonomous Navigation</a></h4>
<ul>
</ul>
<code><a class="el" href="structcarmen__navigator__plan__message.html">carmen_navigator_plan_message</a></code> <p>
<div class="fragment"><pre class="fragment">void carmen_navigator_subscribe_status_message(carmen_navigator_status_message *status,
                                               carmen_handler_t handler,
                                               carmen_subscribe_t subscribe_how);

int carmen_navigator_query_status(carmen_navigator_status_message **status);

</pre></div><p>
The <code>autonomous</code> field is 1 if the robot is currently trying to autonomously navigate to the goal, perhaps because a user clicked the <code>Autonomous</code> button in the navigator display. When the robot changes to non-autonomous mode, a <code><a class="el" href="structcarmen__navigator__autonomous__stopped__message.html">carmen_navigator_autonomous_stopped_message</a></code> is emitted (see below), and contains the reason for changing to non-autonomous mode.<p>
The <code>goal_set</code> field is 1 if the navigator has received any goal at all. If no goal has been set, then it is not possible for the navigator go into autonomous mode.<p>
The <code>goal</code> field reports on what the navigator's current goal. The navigator does not (and should not ever) support multiple goal destinations.<p>
The <code>robot</code> field is the navigator's estimate of the current robot position in the global reference frame (see the Carmen Style Guide). This is based on the latest estimate from localize, combined with any subsequent odometric updates the navigator has received. The <code>robot</code> position field reported by the navigator should never lag behind (in time) localize's estimate.<p>
<ul>
<li><code><a class="el" href="structcarmen__navigator__plan__message.html">carmen_navigator_plan_message</a></code> </li>
</ul>
<div class="fragment"><pre class="fragment">void carmen_navigator_subscribe_plan_message(carmen_navigator_plan_message *plan,
                                           carmen_handler_t handler,
                                           carmen_subscribe_t subscribe_how);

int carmen_navigator_query_plan(carmen_navigator_plan_message **plan);

</pre></div><p>
If the path length is 0, then there is no path from the current robot location to the goal. The first point in the path should always be the robot's current position as reported by the <code><a class="el" href="structcarmen__navigator__status__message.html">carmen_navigator_status_message</a></code>, and the last point in the path should always be the goal as reported by <code><a class="el" href="structcarmen__navigator__status__message.html">carmen_navigator_status_message</a></code>.<p>
<ul>
<li><code><a class="el" href="structcarmen__navigator__autonomous__stopped__message.html">carmen_navigator_autonomous_stopped_message</a></code> </li>
</ul>
<div class="fragment"><pre class="fragment">void carmen_navigator_subscribe_autonomous_stopped_message
                    (carmen_navigator_autonomous_stopped_message *autonomous_stopped,
                     carmen_handler_t handler,
                     carmen_subscribe_t subscribe_how);
</pre></div><p>
The <code>reason</code> field can take one of three values: <ul>
</ul>
<code>CARMEN_NAVIGATOR_GOAL_REACHED_v</code> -- This means that the robot has reached the goal destination (that is, is within the <code>robot_approach_dist</code> of the goal). <ul>
<li><code>CARMEN_NAVIGATOR_USER_STOPPED_v</code> -- This means that some other process (such as the navigator) published a <code>carmen_navigator_stop_message</code>. </li>
<li><code>CARMEN_NAVIGATOR_UNKNOWN_v</code> -- This means some (unknown) reason caused autonomous navigation to stop. The navigator does not currently ever emit this reason. </li>
</ul>
<h2><a class="anchor" name="messages_command">
Commanding the robot</a></h2>
While it is (obviously) possible to send messages directly to the base module, this is not an exposed interface. Sending velocities directly to the base side-steps the last-mile collision avoidance module, and can also result in all kinds of pathologies as modules fight for control of the robot.<h3><a class="anchor" name="messages_moving">
Moving the Robot</a></h3>
<ul>
</ul>
<code><a class="el" href="structcarmen__robot__velocity__message.html">carmen_robot_velocity_message</a></code> <p>
<div class="fragment"><pre class="fragment">void carmen_robot_velocity_command(double tv, double rv);
</pre></div><p>
Publishing this message will tell the <code>robot</code> module to make the robot go at the specified translation velocity <code>tv</code> specified rotational velocity <code>rv</code>.<p>
The robot may not be able to go at these speeds, because either they exceed the maximum velocity, or because an obstacle is too close. There is no diagnostic for the first condition yet. The second condition can be detected by examining the <code>tooclose</code> field of the <code><a class="el" href="structcarmen__robot__laser__message.html">carmen_robot_laser_message</a></code>.<p>
<ul>
<li><code><a class="el" href="structcarmen__robot__vector__move__message.html">carmen_robot_vector_move_message</a></code> </li>
</ul>
<div class="fragment"><pre class="fragment">void carmen_robot_velocity_command(double distance, double theta);
</pre></div><p>
Publishing this message will take advantage of a PD loop in the robot module to make the robot go to specific target point. This control loop contains no planning, so if an obstacle intervenes between the robot and the target, the robot will stop.<p>
The target point set by this message is given by the <code>distance</code> and <code>theta</code> fields, which are in metres and radians respectively, and are {relative} to the robot's current pose. Consequently, a positive <code>distance</code> with a <code>theta</code> of 0 would drive the robot forward <code>distance</code> metres. Similarly, a <code>distance</code> of 0 and a <code>theta</code> of <img class="formulaInl" alt="$\pi$" src="form_3.png"> would cause the robot to rotate <img class="formulaInl" alt="$180^\circ$" src="form_15.png"> , regardless of current orientation.<h3><a class="anchor" name="messages_initloc">
Initializing Localize</a></h3>
<h4><a class="anchor" name="messages_locinimsg">
carmen\_localize\_initialize\_message</a></h4>
This message provides a way to initialize localization.<p>
<div class="fragment"><pre class="fragment">typedef struct {
  int distribution;
  carmen_point_t mean, std;
  double timestamp;
  char* host;
} carmen_localize_initialize_message;
</pre></div><p>
The <code>distribution</code> specifies the kind of distribution to use for initialization. At the moment only one type of distribution is supported: <code>CARMEN_INITIALIZE_GAUSSIAN</code>. (The <code><a class="el" href="localize__messages_8h.html">localize_messages.h</a></code> file also lists a <code>CARMEN_INITIALIZE_UNIFORM</code> distribution type, but this is not currently supported by localize itself.)<p>
The 3-dimensional point <code>mean</code> specifies the <img class="formulaInl" alt="$x, y, \theta$" src="form_16.png"> mean of the gaussian, and <code>std</code> specified the <img class="formulaInl" alt="$\sigma_x, \sigma_y, \sigma_\theta$" src="form_17.png"> standard deviations of the gaussian. Reasonable values for the standard deviations are <img class="formulaInl" alt="$(0.2m, 0.2m, 4.0^\circ)$" src="form_18.png"> .<p>
It is also possible to initialize localize through the navigator by using the <code>carmen_navigator_set_robot</code> or <code>carmen_navigator_set_robot_map</code> messages, but these messages are deprecated.<h4><a class="anchor" name="messages_goal">
Setting A Goal</a></h4>
This message provides a way to set the goal or destination for navigation. It is not possible (nor should it ever be possible) to set multiple goals inside the navigator.<p>
<div class="fragment"><pre class="fragment">typedef struct {
  double x, y;
  double timestamp;
  char* host;
} carmen_navigator_set_goal_message;

int carmen_navigator_set_goal(double x, double y);

typedef struct {
  char *placename;
  double timestamp;
  char* host;
} carmen_navigator_placename_message;

int carmen_navigator_set_goal_place(char *name);

</pre></div><p>
The <img class="formulaInl" alt="$(x, y)$" src="form_19.png"> fields should be self-explanatory as the goal position, in the global reference frame (see the Carmen Style Guide), as always in metres.<p>
If the map contains place names, then it is also possible to set the goal position using a <code><a class="el" href="structcarmen__navigator__placename__message.html">carmen_navigator_placename_message</a></code>, and the <code>carmen_navigator_set_goal_place</code> helper function. This has no effect if the map does not contain a place name that matches.<h3><a class="anchor" name="messages_automon">
Autonomous Motion</a></h3>
These messages toggle the navigator in and out of autonomous motion.<p>
<div class="fragment"><pre class="fragment">typedef struct {
  double timestamp;
  char* host;
} carmen_navigator_go_message;

typedef struct {
  double timestamp;
  char* host;
} carmen_navigator_stop_message;

int carmen_navigator_stop(void);

int carmen_navigator_go(void);

</pre></div><p>
If the robot is already at the current goal position, then the <code>carmen_navigator_go_command</code> will cause the navigator to change momentarily into autonomous mode, and then switch back again, emitting a <code><a class="el" href="structcarmen__navigator__autonomous__stopped__message.html">carmen_navigator_autonomous_stopped_message</a></code> with <code>CARMEN_NAVIGATOR_GOAL_REACHED_v</code> as the reason.<p>
When the navigator receives a <code>carmen_navigator_stop_message</code>, then a <code><a class="el" href="structcarmen__navigator__autonomous__stopped__message.html">carmen_navigator_autonomous_stopped_message</a></code> is emitted with <code>CARMEN_NAVIGATOR_USER_STOPPED_v</code> as the reason.<h2><a class="anchor" name="gettingparams">
Getting Parameters</a></h2>
Parameters can be acquired from the parameter server using functions in <code>libparam_interface</code>, eg:<p>
<div class="fragment"><pre class="fragment">int carmen_param_get_int(char *variable, int *return_value);
int carmen_param_get_double(char *variable, double *return_value);
int carmen_param_get_onoff(char *variable, int *return_value);
int carmen_param_get_string(char *variable, char **return_value);
</pre></div><p>
The conversion of parameters to ints, doubles, etc. is done on demanded by the interface library. If you do not wish the library to convert the parameter to the appropriate type, simply request the parameter as a string.<p>
If there is no definition for the parameter requested, then the library will output a warning to the terminal, unless this warning has been turned off using <code>carmen_param_allow_unfound_variables(1)</code>;.<p>
Also, as a convience, variables can be requested either by specifying the fully qualified <code>module_param-name</code> name, or by first specifying a module using <code><a class="el" href="group__param__daemon.html#ga8">carmen_param_set_module(char *)</a></code>, and the specifying just the <code>param-name</code> form.<h3><a class="anchor" name="messages_subchange">
Subscribing to Changes</a></h3>
Some processes may wish to subscribe to changes to parameters during their execution, for example changing the robot speed or acceleration profile, or changing the <code>robotgraph</code> display parameters. Of course, some processes should not suscribe to some parameter changes: changing the number of particles localize uses during execution would result in disaster.<p>
Parameter changes can be subscribed using the functions below: <div class="fragment"><pre class="fragment">void carmen_param_subscribe_int(char *module, char *variable, int *variable_address, 
                                carmen_param_change_handler_t handler);
void carmen_param_subscribe_double(char *module, char *variable, double *variable_address, 
                                   carmen_param_change_handler_t handler);
void carmen_param_subscribe_onoff(char *module, char *variable, int *variable_address, 
                                  carmen_param_change_handler_t handler);
void carmen_param_subscribe_string(char *module, char *variable, char **variable_address, 
                                   carmen_param_change_handler_t handler);
</pre></div><p>
These functions take a module and variable name as parameters. The subscription mechanism can either silently change variable values as parameters change, or can invoke a callback when a parameter is changed. If the <code>variable_address</code> parameter is non-NULL, then the new parameter value is stored at this address (in the case of strings, this is a pointer to some newly-malloc'd memory containing the new string definition. If the variable address is non-NULL when the parameter changes, the old memory is freed.) If the <code>handler</code> parameter is non-NULL, then function pointed to by <code>handler</code> is invoked whenever the parameter changes. If both are non-NULL, then the variable changes and then the callback invoked. If both are NULL, then the subscription mechanism does not do much.<h3><a class="anchor" name="messages_fac">
The Parameter Factory</a></h3>
Parameters can be loaded in a single step using the parameter factory methods, much like the gtk menu item factory methods. The set of parameters to be loaded should be described in an array of <code><a class="el" href="structcarmen__param__t.html">carmen_param_t</a></code>, and passed to <div class="fragment"><pre class="fragment">void carmen_param_install_params(int argc, char *argv[], carmen_param_p param_list, 
                                 int num_items);
</pre></div><p>
Each parameter in the array of type <code><a class="el" href="structcarmen__param__t.html">carmen_param_t</a></code> has the form: <div class="fragment"><pre class="fragment">typedef struct {
  char *module;
  char *variable;
  carmen_param_type_t type;
  void *user_variable;
  int subscribe;
  carmen_param_change_handler_t handler;
} carmen_param_t;
</pre></div> where <code>module</code> is the module name, <code>variable</code> is the variable name, <code>type</code> is one of <code>CARMEN_PARAM_INT</code>, <code>CARMEN_PARAM_DOUBLE</code>, <code>CARMEN_PARAM_ONOFF</code> or <code>CARMEN_PARAM_STRING</code>. The parameter is loaded into <code>user_variable</code>, whose original type should match that specified in the <code>type</code> field.<p>
If <code>subscribe</code> is set to 1, then the process will subscribe to changes to the parameter, and set up a callback on the function specified in <code>handler</code> (if not NULL). The callback parameter is ignored if <code>subscribe</code> is set to 0, and the parameter is only loaded once. There is no way to use the parameter factory methods, subscribe to a variable and not have the variable's value updated automatically.<p>
If <code><a class="el" href="group__param__daemon.html#ga24">carmen_param_allow_unfound_variables()</a></code> is set to 0 (by default), then <code>carmen_param_install_params</code> will exit with an error on the first parameter absent from the parameter server, reporting what the problematic parameter is.<p>
If a process loads its parameter set using the parameter factory methods, then running the process with the <code>-h</code> or <code>-help</code> command line option will print out a list of parameters used by that process, their expected types and whether or not the process subscribes to changes. <hr size="1"><address style="align: right;"><small>Generated on Wed Apr 5 18:34:20 2006 for CARMEN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>

<!-- Mirrored from carmen.sourceforge.net/doc/messages.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 13 Jan 2011 17:36:14 GMT -->
</html>
