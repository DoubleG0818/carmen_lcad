<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from carmen.sourceforge.net/doc/style.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 13 Jan 2011 17:36:04 GMT -->
<head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CARMEN: </title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<h2>The CARMEN Style Guide</h2>
<h2><a class="anchor" name="style_prim">
The Prime directive</a></h2>
You are not the only person who will ever have to read, understand and modify your code.<h2><a class="anchor" name="style_units">
Units and Coordinates</a></h2>
<ul>
</ul>
Always represent all units in MKS. All distances are <em>always</em> in metres. All angles are <em>always</em>, <em>always</em> in radians.<p>
<ul>
<li>All floating point numbers should be doubles, not floats, and all fixed point numbers should be ints, not chars or shorts. The only known exceptions are large, low-precision data chunks, i.e. laser data and maps.</li>
</ul>
<ul>
<li>All co-ordinate frames, internal and external, are right-handed. This means that <img class="formulaInl" alt="$\theta$" src="form_0.png"> <em>always</em> increases counter-clockwise, from positive x to positive y. This is the <em>opposite</em> of screen graphics.</li>
</ul>
<ul>
<li><img class="formulaInl" alt="$\theta = 0$" src="form_1.png"> <em>always</em> points along the positive x axis.</li>
</ul>
<ul>
<li>There are exactly three allowable co-ordinate frames. <ul>
</ul>
The robot's frame of reference. Distances are in metres, and the robot always faces along the positive x axis. </li>
<li>The global frame of reference. Distances are in metres, and <img class="formulaInl" alt="$\theta = 0$" src="form_1.png"> is with respect to a map. This is a meaningless frame of reference without a map. </li>
<li>The map frame of reference. Distances are in grid cells, and <img class="formulaInl" alt="$\theta = 0$" src="form_1.png"> is with respect to a map. This is a meaningless frame of reference without a map. </li>
</ul>
<ul>
<li>Never convert between radians and degrees yourself. Always use \ <code>carmen_radians_to_degrees</code> and <code>carmen_degrees_to_radians</code>.</li>
</ul>
<ul>
<li>Angles are always between <img class="formulaInl" alt="$-\pi$" src="form_2.png"> and <img class="formulaInl" alt="$\pi$" src="form_3.png"> . Never normalize angles yourself. Always use <code>carmen_normalize_theta</code>.</li>
</ul>
<ul>
<li>Never use <code>asin</code>, <code>acos</code> or <code>atan</code> to recover angles distances. Always use <code>atan2</code> (3). <div class="fragment"><pre class="fragment">           theta = atan2(y, x);
</pre></div> should always be used instead of <div class="fragment"><pre class="fragment">           theta = atan(y/x);
</pre></div></li>
</ul>
<ul>
<li>If you need the hypotenuse of something, use <code>hypot</code> (3) -- do not take the sum of squares and find the square root. <code>hypot</code> (3) should be used for code clarity.</li>
</ul>
<ul>
<li>Try not to invent your own data structures. Use one of <ul>
</ul>
<code><a class="el" href="structcarmen__point__t.html">carmen_point_t</a></code> </li>
<li><code><a class="el" href="structcarmen__traj__point__t.html">carmen_traj_point_t</a></code> </li>
<li><code>carmen_map_point_t</code> </li>
<li><code>carmen_world_point_t</code>  making sure that you use the right data structure to store the right kind of data.</li>
</ul>
<ul>
<li>When converting between coordinate frames, use the helper functions in <code><a class="el" href="map__interface_8h.html">map_interface.h</a></code> and <code><a class="el" href="global_8h.html">global.h</a></code>.</li>
</ul>
<ul>
<li>When drawing to the screen, do not maintain internal representations of data in screen co-ordinates. Convert to screen co-ordinates only immediately before calling extern graphics functions. Use the helper functions in <code>global_graphics.h</code>.</li>
</ul>
<h2><a class="anchor" name="style_naming">
Naming conventions</a></h2>
<ul>
</ul>
The most important naming convention is to expect that your code could be converted into a library one day. Therefore, it is important to think about global name spaces.<p>
<ul>
<li>As many functions and global variables should be static as possible. In general, try to avoid global variables.</li>
</ul>
<ul>
<li>Static global variables with accessor functions are preferable to non-static globals.</li>
</ul>
<ul>
<li>Any non-static functions and global variables must have the prepend <code>carmen_{module-name}</code>. e.g., <code>carmen_base_subscribe_odometry</code>.</li>
</ul>
<h2><a class="anchor" name="style_memory">
Memory management, system calls, and functions with side effects</a></h2>
<ul>
</ul>
Never use a system call without checking the return value. This includes any memory allocation. We have provided a function \ <code>carmen_test_alloc</code> that facilitates memory checking. CVS will not allow code to be committed to core CARMEN that contains a call to malloc/calloc/realloc and does not have a call to <code>carmen_test_alloc</code> on the subsequent line.<p>
<ul>
<li>When using statically allocated arrays, especially strings, never make the array ``just big enough''.</li>
</ul>
<ul>
</ul>
Wrong: <code>char</code> buffer[11] for a string of length 10. <ul>
<li>Right: <code>char</code> buffer[1024] for a string of length 10. </li>
</ul>
Why? You minimize the probability of off-by-one errors writing into memory you don't own. Memory is cheap. If you really need to create ``just-big-enough'' memory arrays because you're running out of memory, you're solving the wrong problem.<p>
<ul>
<li>Never use fscanf, gets, etc to read into buffers without limit.</li>
</ul>
<ul>
<li>Never make a system call, and check its side effect in one step. For example, <div class="fragment"><pre class="fragment">           fd = open(filename, O_RDONLY);
           if (fd &lt; 0)
             return -1;
</pre></div> should always be used instead of <div class="fragment"><pre class="fragment">           if ((fd = open(filename, O_RDONLY)) &lt; 0)
             return -1;
</pre></div> This is for two reasons: <ul>
</ul>
Code clarity : it is easier to read the former than the latter. </li>
<li>Debugging : it is easier to use a debugger with the former than the latter. </li>
</ul>
<ul>
<li>Avoid macros. If you must have a macro, write an inline function instead. Macros can hurt you in the following manner: <div class="fragment"><pre class="fragment">           #define MAX(X, Y) ((X) &gt; (Y) ? (X) : (Y))
           ...
                  max_x = MAX(X++, Y++);
</pre></div> The larger of the two fields will be incremented <em>twice</em>. Instead, use: <div class="fragment"><pre class="fragment">           inline int max_int(int x, int y) {
             return (x &gt; y ? x : y);
           }
</pre></div> Under compiler flags <code>-O</code>, these two code fragments are compiled identically under gcc, but the macro has unexpected side-effects.</li>
</ul>
<ul>
<li>Never generate random numbers yourself. You will do it wrong. Always use one of <code>carmen_int_random</code>, <code>carmen_uniform_random</code> or <code>carmen_gaussian_random</code>. Consult the documentation for these functions to find out which random algorithm they use.</li>
</ul>
<ul>
<li>Never create random number seeds yourself. You will do it wrong. Always use <code>carmen_randomize</code>. This function randomizes by reading a seed from <code>/dev/random</code>.</li>
</ul>
<h2><a class="anchor" name="style_ipc">
IPC</a></h2>
<ul>
</ul>
Do not initialize IPC yourself. Use <code>carmen_initialize_ipc</code>.<p>
<ul>
<li>If you write a stand-alone module, there should be three separate files with your module: <ul>
</ul>
<code>{module}_messages.h</code> -- this contains the IPC message definitions. </li>
<li><code>{module}_interface.h</code> -- this contains the function prototypes for communicating with your module. </li>
<li><code>{module}_interface.c</code> -- this contains the actual functions for communicating with your module. This file should be compiled into a library. </li>
</ul>
We expect that all modules will have well-defined interface libraries that relieve the user of having to worry about marshalling data.<p>
<ul>
<li>Every IPC message should have a timestamp and hostname field. The hostname should be 10 chars long, and should be a canonical representation of the machine on which the process is running that created the message. Use the helper function <code>carmen_get_tenchar_host_name()</code> to generate the hostname.</li>
</ul>
The timestamp should also reflect the time of creation of the <em>data</em>, not the time the message was published. For instance, the laser message timestamp is the time the data was read from the serial port. Use the helper function <code>carmen_get_time_ms()</code> to generate the timestamp as a double.<h2><a class="anchor" name="style_graphics">
Graphics</a></h2>
<ul>
</ul>
Keep graphics and robot functionality in separate processes.<p>
Notice that none of the core robot functionality (<code>base_services</code>, <code>robot</code>, <code>navigator</code>, <code>localize</code>) link against graphics libraries. This is for multiple reasons:<p>
<ul>
</ul>
It increases the likelihood that your code will work on a standalone robot in the absence of a network. If your process is displaying output to a remote X window, and the network drops out, your process <em>will</em> wedge until the network comes back. If, however, your process is sending IPC messages to an external display process, then only the display process will wedge, not your (presumably more important) robot process.<p>
<ul>
<li>You are removed from the temptation of displaying internal information not accessible to external code. If you want to <em>see</em> the state of your process, the odds are very high that eventually, someone else will want to <em>use</em> the state of your process. By forcing you to write an IPC message and interface handler for that information just to get it into the display, you make life much easier for people who come after you.</li>
</ul>
<ul>
<li>Allowing your code to compile without graphics makes it more portable, and makes it more distributable, in the sense that it can run anywhere -- it is not constrained by the speed of network connections between machines. </li>
</ul>
For obvious reasons, programs like map and mapper have displays compiled in -- these programs are not intended for autonomous use on the robot.  <hr size="1"><address style="align: right;"><small>Generated on Wed Apr 5 18:34:20 2006 for CARMEN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>

<!-- Mirrored from carmen.sourceforge.net/doc/style.html by HTTrack Website Copier/3.x [XR&CO'2010], Thu, 13 Jan 2011 17:36:06 GMT -->
</html>
