'''
This program read a SVG file generated by InkScape and searches for "paths" containing a sequence of points centered on a road lane and the lane width.
The paths are then expanded in all points according to the cubic Bezier curve algorithm.
The road lane map is generated for all points within the lane width, setting the x- and y-pixel distances to the center of the lane. 
'''


from xml.dom import minidom
import numpy as np
import cv2
import struct

# Global definitions
BEZIER_INCREMENT = 0.001    # Line length increment (from 0.000 to 1.000) to set cubic Bezier curve points  
STROKE_INCREMENT = 0.05     # Line width increment  (in subpixels) to set the distance from the pixel to the line center 
MAX_INTENSITY = 255.0       # Maximum color intensity of pixel on the line center 
MIN_INTENSITY = 25.0        # Minimum color intensity of pixel on the line border
SHIFT = 16                  # Number of bits used for the fractionary part of a pixel coordinate 
MM_PER_PIXEL = 200.0        # Pixel length in millimetersfrom xml.dom import minidom
import numpy as np
import cv2
import struct

# Global definitions
BEZIER_INCREMENT = 0.001    # Line length increment (from 0.000 to 1.000) to set cubic Bezier curve points  
STROKE_INCREMENT = 0.05     # Line width increment  (in subpixels) to set the distance from the pixel to the line center 
MAX_INTENSITY = 255.0       # Maximum color intensity of pixel on the line center 
MIN_INTENSITY = 25.0        # Minimum color intensity of pixel on the line border
SHIFT = 16                  # Number of bits used for the fractionary part of a pixel coordinate 
MM_PER_PIXEL = 200.0        # Pixel length in millimeters
SQRT2DIV2 = sqrt(2.0) * 0.5

class road:
    def __init__(self):
        self.distance_center = 0    # short int: 'h'
        self.x_orientation = 0      # short int: 'h'
        self.y_orientation = 0      # short int: 'h'
        self.left_marking = 0       # char: 'b'
        self.right_marking = 0      # char: 'b'
         
      
#https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
def svg_d_get_bezier_points(d):
    letter = ''
    count = 0
    points = [] # list of (x,y)
    last_abs_point_i = 0
    errors = 0
    for p in d.split(' '):    
        if len(p) == 1:
            if p == 'm' or p == 'M' or p == 'c' or p == 'C' or p == 'l' or p == 'L' or p == 'h' or p == 'H' or p == 'v' or p == 'V':
                if p != letter:
                    count = 0
                letter = p
            else:
                errors += 1
        else:  
            if letter == 'm' or letter == 'M': # Move cursor to (x,y), lowercase = relative coordinates, uppercase = absolute coordinates
                pt = p.split(',')
                if len(pt) == 2:
                    points.append((float(pt[0]), float(pt[1])))
                else:
                    errors += 1             
            elif letter == 'c': # Cubic Bezier curve, lowercase = relative coordinates
                count += 1   
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))     
                    if count % 3 == 0:
                        last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'C': # Cubic Bezier curve, uppercase = absolute coordinates
                count += 1            
                pt = p.split(',') 
                if len(pt) == 2:
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                else:
                    errors +=1                            
            elif letter == 'l': # Draw straight line to next point (x,y), lowercase = relative coordinates
                delta = p.split(',')
                # calculate absolute point
                if len(delta) == 2:                
                    points.append(points[len(points) - 1]) # Repeat last point just to fake the Bezier algorithm
                    pt[0] = float(delta[0]) + points[last_abs_point_i][0]
                    pt[1] = float(delta[1]) + points[last_abs_point_i][1]
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[len(points) - 1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            elif letter == 'L': # Draw straight line to next point (x,y), uppercase = absolute coordinates
                pt = p.split(',') 
                if len(pt) == 2:                
                    points.append(points[len(points) - 1]) # Repeat last point just to fake the Bezier algorithm
                    points.append((float(pt[0]), float(pt[1])))
                    last_abs_point_i = len(points) - 1
                    points.append(points[len(points) - 1]) # Repeat new point just to fake the Bezier algorithm
                else:
                    errors += 1             
            else:
                errors += 1
        if errors == 1:
            print 'Error in SVG line: d="', d, '"'
        if errors >= 1:
            print 'Unexpected SVG token: ', p
    return points

#https://stackoverflow.com/questions/15857818/python-svg-parser
def svg_get_paths(svg_file):
    doc = minidom.parse(svg_file)  # parseString also exists    
    paths = []
    img = doc.getElementsByTagName('image')
    width = int(img[0].getAttribute('width'))
    height = int(img[0].getAttribute('height'))
    for path in doc.getElementsByTagName('path'):
        d = path.getAttribute('d')
        points = svg_d_get_bezier_points(d)
        for style in path.getAttribute('style').split(';'):
            s = style.split(':')
            if s[0] == 'stroke-width':
                stroke_width = float(s[1]) 
                break;
        paths.append((points, stroke_width))
    doc.unlink()
    return width, height, paths

#https://stackoverflow.com/questions/785097/how-do-i-implement-a-b%C3%A9zier-curve-in-c
#https://stackoverflow.com/questions/37642168/how-to-convert-quadratic-bezier-curve-code-into-cubic-bezier-curve
def getPt(n1, n2 , perc):
    diff = n2 - n1;
    return n1 + ( diff * perc )
 
def get_bezier(width, height, points):  
    bx = []
    by = []
    btan = []
    for i in range((len(points)-1)/3):
        j = 0.0
        while j <= 1.0:
            # The Green Lines
            xa = getPt(points[i*3][0], points[i*3+1][0], j)
            ya = getPt(points[i*3][1], points[i*3+1][1], j)
            xb = getPt(points[i*3+1][0], points[i*3+2][0], j)
            yb = getPt(points[i*3+1][1], points[i*3+2][1], j)
            xc = getPt(points[i*3+2][0], points[i*3+3][0], j)
            yc = getPt(points[i*3+2][1], points[i*3+3][1], j) 
            # The Blue Line
            xm = getPt(xa, xb, j)
            ym = getPt(ya, yb, j)
            xn = getPt(xb, xc, j)
            yn = getPt(yb, yc, j)    
            # The Black Dot
            x = getPt(xm, xn, j)
            y = getPt(ym, yn, j)      
            bx.append(x)
            by.append(y)
            if len(bx) > 1:
                x1 = x
                y1 = height - y # Y axis origin is upside down
                x0 = bx[-2]
                y0 = height - by[-2] # Y axis origin is upside down
                t = np.arctan2(y1 - y0 , x1 - x0)
                btan.append(t)
            j += BEZIER_INCREMENT
    btan2 = []
    btan2.append(btan[0])
    for i in range(1, len(btan)): # len(btan) = len(btan2)-1
        btan2.append(btan[i-1] + btan[i]) / 2.0
    btan2.append(btan[len(btan)-1]) 
    return bx, by, btan2

def get_lane_from_bezier(img, bx, by, btan, stroke_width):
    last_x = last_y = 'null'
    radius = stroke_width * SQRT2DIV2 
    for i in range(len(bx)):
        if round(bx[i]) != last_x and round(by[i]) != last_y:
            last_x = x = round(bx[i])
            last_y = y = round(by[i])
            
    return img

if __name__ == "__main__":
    svg_file =  'i7705600_-338380.00.svg'
    print 'Processing SVG file: ', svg_file
    cv2.namedWindow("original")
    cv2.namedWindow("median_blur")
    width, height, paths = svg_get_paths(svg_file)
    img = np.zeros((height, width, 3), np.uint8)
    for path in paths:
        bx, by, btan = get_bezier(width, height, path[0])
        img = get_lane_from_bezier(img, bx, by, btan, path[1])
        img2 = cv2.medianBlur(img, 5)
    cv2.imshow("original", img)
    cv2.imshow("median_blur", img2)
    cv2.waitKey(0)
    road_file = open('r' + svg_file[1:-3] + 'map', 'wb')
    for i in range(height):
        for j in range(width):
            distance_center = int(MM_PER_PIXEL * (MAX_INTENSITY - img[i, j, 0]) * (path[1] / 2.0) / (MAX_INTENSITY - MIN_INTENSITY))
            map = struct.pack('hhhbb', distance_center, 0,0,0,0)
            road_file.write(map)
